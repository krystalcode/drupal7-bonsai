<?php
/**
 * @file
 * Code for the Bonsai feature.
 */

include_once 'bonsai.features.inc';
include_once 'includes/bonsai.theme.inc';
include_once 'includes/bonsai.field_formatter.inc';

// External dependencies.
use Bonsai\Mailgun\Repository;
use Symfony\Component\EventDispatcher\EventDispatcher;

// Internal dependencies.
use Drupal\bonsai\Mailgun\MessageToNodeTransformer;


/**
 * @Issue(
 *   "Define admin page for setting required system variables"
 *   type="improvement"
 *   priority="normal"
 *   labels="administration, configuration"
 * )
 * @Issue(
 *   "Throw exceptions when required configuration variables are not defined"
 *   type="improvement"
 *   priority="normal"
 *   labels="configuration"
 * )
 * @Issue(
 *   "Add a composer.json file for defining composer dependencies"
 *   type="bug"
 *   priority="normal"
 * )
 * @Issue(
 *   "Allow users to change the default authentic/spam field, or flag messages
 *   using the flag module"
 *   type="improvement"
 *   priority="normal"
 * )
 */


/**
 * Hooks.
 */

/**
 * Implements hook_menu().
 */
function bonsai_menu() {
  $items = array();

  // Menu item for image attachment call for message nodes.
  $items['bonsai/messages/%node/attachments/add'] = array(
    'title' => 'Add Attachments',
    'page callback' => '_bonsai_attachments_add_page',
    'page arguments' => array(2),
    'access callback' => '_bonsai_attachments_add_access',
    'access arguments' => array(2),
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function bonsai_permission() {
  $permissions = array(
    'bonsai fetch attachments' => array(
      'title' => t('Fetch attachments from the source and add them to messages'),
    ),
    'bonsai send messages' => array(
      'title' => t('Send messages'),
    ),
    'bonsai view messages' => array(
      'title' => t('View messages'),
    ),
    'bonsai view messages source' => array(
      'title' => t('View the source of messages'),
    ),
  );

  return $permissions;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function bonsai_form_bonsai_message_email_node_form_alter(&$form, &$form_state, $form_id) {
  // We will be populating the user fields in hook_node_presave(), so disallow
  // all users from updating these fields.
  $form['bonsai_user_ref']['#access']   = FALSE;
  $form['bonsai_users_ref']['#access']  = FALSE;
  $form['bonsai_users_ref2']['#access'] = FALSE;
  $form['bonsai_users_ref3']['#access'] = FALSE;
}

/**
 * Implements hook_node_presave().
 *
 * @Issue(
 *   "Optimise the algorithm for updating the users corresponding to a message's
 *   emails"
 *   type="improvement"
 *   priority="low"
 *   labels="performance"
 * )
 */
function bonsai_node_presave($node) {
  // We are not going to save the node here, so we are only using the entity
  // wrapper for easily fetching field values - we're gonna do this a lot.
  $node_wrapper = entity_metadata_wrapper('node', $node);

  // The emails in minimal format.
  $sender_email          = _bonsai_full_format_to_email($node_wrapper->bonsai_email->value());
  $recipients_emails     = array_map('_bonsai_full_format_to_email', $node_wrapper->bonsai_emails->value());
  $cc_recipients_emails  = array_map('_bonsai_full_format_to_email', $node_wrapper->bonsai_emails2->value());
  $bcc_recipients_emails = array_map('_bonsai_full_format_to_email', $node_wrapper->bonsai_emails3->value());

  // Get a list of all emails so that we fetch the users only once (instead of
  // fetching the users for sender, recipients, CC recipients and BCC recipients
  // separately). That complicates the algorithm a bit, but it can be a
  // significant performance improvement.
  $emails = array_merge(
    array($sender_email),
    $recipients_emails
  );

  if (!empty($cc_recipients_emails)) {
    $emails = array_merge(
      $emails,
      $cc_recipients_emails
    );
  }

  if (!empty($bcc_recipients_emails)) {
    $emails = array_merge(
      $emails,
      $bcc_recipients_emails
    );
  }

  $uids = _bonsai_uids_by_emails($emails);

  // Nothing to do if there are no matching users.
  if (empty($uids)) {
    return;
  }

  $users = user_load_multiple($uids);

  // We loop over found users and we check on which user reference fields they
  // should be added to.
  $sender_found        = FALSE;
  $recipients_uids     = array();
  $cc_recipients_uids  = array();
  $bcc_recipients_uids = array();

  foreach ($users as $user) {
    // Check the sender. The sender can only ever be one, so we use a variable
    // to track when we have found it so that we don't make unnecessary checks.
    if (!$sender_found && $user->mail === $sender_email) {
      $node_wrapper->bonsai_user_ref->set($user->uid);
      $sender_found = TRUE;
    }

    // Check the recipients.
    foreach ($recipients_emails as $email) {
      if ($user->mail === $email) {
        $recipients_uids[] = $user->uid;
      }
    }

    // Check the CC recipients.
    foreach ($cc_recipients_emails as $email) {
      if ($user->mail === $email) {
        $cc_recipients_uids[] = $user->uid;
      }
    }

    // Check the BCC recipients.
    foreach ($bcc_recipients_emails as $email) {
      if ($user->mail === $email) {
        $bcc_recipients_uids[] = $user->uid;
      }
    }
  }

  // Set the users we've found, apart from the sender we has already been set.
  if (!empty($recipients_uids)) {
    $node_wrapper->bonsai_users_ref->set($recipients_uids);
  }
  if (!empty($cc_recipients_uids)) {
    $node_wrapper->bonsai_users_ref2->set($cc_recipients_uids);
  }
  if (!empty($bcc_recipients_uids)) {
    $node_wrapper->bonsai_users_ref3->set($bcc_recipients_uids);
  }
}

/**
 * Implements hook_cron().
 *
 * Defines a cron item for regularly fetching new messages from the email
 * service provider.
 */
function bonsai_cron() {
  // Fetch new messages from the email service provider.
  $domain     = variable_get('bonsai_domain');
  $repository = bonsai_get_repository();
  $messages   = $repository->getList(
    array(
      'domain' => $domain,
      /**
       * @Issue(
       *   "Define the number of messages to fetch per cron run as a system
       *   variable"
       *   type="improvement"
       *   priority="low"
       *   labels="administration, configuration"
       * )
       */
      'limit'  => variable_get('bonsai_cron_messages_limit', 100),
    )
  );

  if (empty($messages)) {
    return;
  }

  $queue = DrupalQueue::get('bonsai_messages');

  // Store each message to the queue for separately processing it later.
  foreach ($messages as $message) {
    if (empty($message)) {
      continue;
    }

    // Do not reprocess messages that have already been stored as nodes.
    /**
     * @Issue(
     *   "Use an EventSubscriber for filtering out messages that have already
     *   been processed"
     *   type="improvement"
     *   priority="performance"
     * )
     */
    $node_exists = _bonsai_email_message_exists($message);
    if ($node_exists) {
      return;
    }

    $queue->createItem($message);
  }
}

/**
 * Implements hook_cron_queue_info().
 */
function bonsai_cron_queue_info() {
  $items = array();

  // Queue for processing newly fetched messages.
  $items['bonsai_messages'] = array(
    'worker callback' => '_bonsai_queue_worker__bonsai_messages',
  );

  // Queue for detecting the parents of an email. It may also be used to add a
  // message to a new or existing conversation.
  $items['bonsai_conversations'] = array(
    'worker callback' => '_bonsai_queue_worker__bonsai_conversations',
  );

  return $items;
}


/**
 * Public API.
 */

/**
 * Get the client for the email service provider.
 *
 * The client is required for creating the repository for the email service
 * provider. It could be created by a Service Container, but Drupal 7 does not
 * have one. It may also be used to make direct requests to the service
 * provider's API.
 *
 * Only Mailgun is supported at the moment, so we create and return the client
 * directly.
 */
function bonsai_get_client() {
  $api_key = variable_get('bonsai_mailgun_api_key');
  return new \Mailgun\Mailgun($api_key);
}

/**
 * Get the repository for the email service provider.
 *
 * The repository is used for fetching or sending email messages.
 *
 * Only Mailgun is supported at the moment, so we create and return the
 * repository directly.
 */
function bonsai_get_repository() {
  $api_key     = variable_get('bonsai_mailgun_api_key');
  $client      = bonsai_get_client();
  $dispatcher  = new EventDispatcher();
  $transformer = new MessageToNodeTransformer();
  $repository  = new Repository($client, $dispatcher, $api_key, $transformer);

  return $repository;
}


/**
 * Callbacks.
 */

/**
 * Implements callback_queue_worker().
 *
 * Given a node entity wrapper that represents a message fetched from the email
 * service provider, it prepares it and stores it as an email message node.
 *
 * @Issue(
 *   "Do the full transformation from message to node during processing queue
 *   items, instead of partly doing so on cron run"
 *   type="improvement"
 *   priority="low"
 * )
 */
function _bonsai_queue_worker__bonsai_messages($node_wrapper) {
  if (empty($node_wrapper)) {
    return;
  }

  // Make sure that the message does not already exists. This shouldn't happen
  // since we check before creating the queue item as well, but it is good to
  // double check to prevent duplicate messages in the case of a regression bug.
  $node_exists = _bonsai_email_message_exists($node_wrapper);
  if ($node_exists) {
    return;
  }

  /**
   * @Issue(
   *   "Detect and store users that correspond to sender and recipients"
   *   type="bug"
   *   priority="normal"
   *   labels="data"
   * )
   */

  // Detect if there is a parent email, and save its id in the appropriate
  // field.
  $parent_email_id = _bonsai_email_email_has_header($node_wrapper->bonsai_json->value(), 'In-Reply-To');

  if ($parent_email_id) {
    $parent_node_id = _bonsai_email_email_has_parent($parent_email_id);
    if ($parent_node_id) {
      $node_wrapper->bonsai_message_email_ref = $parent_node_id;
    }
  }

  $node_wrapper->save();

  // If the email has a parent, but a node does not already exist for the
  // parent, we create a queue item for detecting it later. It may be that the
  // parent email is in the queue and the corresponding node has not been
  // created yet.
  if ($parent_email_id && !$parent_node_id) {
    $queue = DrupalQueue::get('bonsai_conversations');
    $queue->createItem($node_wrapper->getIdentifier());
  }
}

/**
 * Implements callback_queue_worker().
 *
 * Given the id of an email message node, it detects if the node's email has a
 * parent email that is stored as a node, and it stores it in the corresponding
 * entity reference field that indicates parent relationship.
 */
function _bonsai_queue_worker__bonsai_conversations($node_id) {
  $node         = node_load($node_id);
  $node_wrapper = entity_metadata_wrapper('node', $node);

  // Check if the node's email has a parent email.
  $parent_email_id = _bonsai_email_email_has_header(
    $node_wrapper->bonsai_json->value(),
    'In-Reply-To'
  );

  // Nothing to do if the email does not have a parent. This shouldn't normally
  // happen because we wouldn't put an email that doesn't have a parent in this
  // queue, but it's good to double check in order to prevent errors in the case
  // of a regression bug.
  if (!$parent_email_id) {
    return;
  }

  // Get the parent node, if it exists.
  $parent_node_id = _bonsai_email_email_has_parent($parent_email_id);

  // If the parent node exists, store it as a reference in the appropriate
  // field.
  if ($parent_node_id) {
    $node_wrapper->bonsai_message_email_ref = $parent_node_id;
    $node_wrapper->save();
  }
  // If the email has a parent, but a node does not exist for it yet, we
  // create a queue item for detecting it later. It may be that the
  // parent email is still in the queue and the corresponding node has not
  // been created yet.
  /**
   * @Issue(
   *   "Stop trying to repeatedly detect the parent email after a certain
   *   period of time"
   *   type="bug"
   *   priority="low"
   *   labels="cron, deadlock"
   */
  else {
    $queue = DrupalQueue::get('bonsai_conversations');
    $queue->createItem($node_wrapper->getIdentifier());
  }
}


/**
 * Functions for internal use.
 */

/**
 * @Issue(
 *   "Document functions for internal use"
 *   type="improvement"
 *   priority="low"
 *   labels="documentation"
 * )
 */

function _bonsai_email_message_exists($node_wrapper) {
  // The Bonsai library will return a NULL value when fetching emails older than
  // 3 days. Detect that and do nothing to avoid errors, even though this
  // function is not/should not be called in such cases.
  if (empty($node_wrapper)) {
    return;
  }

  $email_id = $node_wrapper->bonsai_email_id->value();

  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'node')
    ->propertyCondition('type', 'bonsai_message_email')
    ->fieldCondition('bonsai_email_id', 'value', $email_id)
    ->range(0, 1)
  ;
  $result = $query->execute();

  if (empty($result['node'])) {
    return FALSE;
  }

  return TRUE;
}

function _bonsai_email_trim_email_id($email_id) {
  return trim($email_id, '<>');
}

function _bonsai_email_email_has_parent($email_id) {
  $email_id = _bonsai_email_trim_email_id($email_id);

  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'node')
    ->propertyCondition('type', 'bonsai_message_email')
    ->fieldCondition('bonsai_email_id', 'value', $email_id)
    ->range(0, 1)
  ;
  $result = $query->execute();

  if (empty($result['node'])) {
    return FALSE;
  }

  $node = current($result['node']);
  return $node->nid;
}

function _bonsai_full_format_to_email($email) {
  $email_start = strpos($email, '<');

  if ($email_start === FALSE || substr($email, -1) !== '>') {
    return $email;
  }

  return substr($email, $email_start+1, -1);
}

function _bonsai_uids_by_emails(array $emails) {
  if (empty($emails)) {
    return array();
  }

  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'user')
    ->propertyCondition('mail', $emails, 'IN')
  ;
  $result = $query->execute();

  if (empty($result['user'])) {
    return array();
  }

  return array_keys($result['user']);
}

function _bonsai_email_email_has_header($email_json, $header) {
  $message = json_decode($email_json);

  if (empty($message->{'message-headers'})) {
    return FALSE;
  }

  foreach ($message->{'message-headers'} as $message_header) {
    if ($message_header[0] === $header) {
      return $message_header[1];
    }
  }

  return FALSE;
}

function _bonsai_node_add_attachment($attachment, $node_wrapper) {
  // We will be using the entity wrapper for manipulating fields. If we are
  // given the node id or the node object, wrap it in an entity wrapper.
  if (is_numeric($node_wrapper) && is_int((int) $node_wrapper)) {
    $node_wrapper = node_load($node_wrapper);
  }
  if (is_object($node_wrapper) && get_class($node_wrapper) !== 'EntityDrupalWrapper') {
    $node_wrapper = entity_metadata_wrapper('node', $node_wrapper);
  }

  // Determine the field where the file will be attached, depending on the
  // attachment's content type.
  $image_content_types = array(
    'image/gif',
    'image/jpeg',
    'image/png',
  );
  if (in_array($attachment->{'content-type'}, $image_content_types)) {
    $field_name = 'bonsai_images';
  }
  else {
    $field_name = 'bonsai_files';
  }

  // Get the field settings for determining the full storage path where the file
  // will be stored.
  $instance_info  = field_info_instance('node', $field_name, $node_wrapper->type->value());
  $file_directory = $instance_info['settings']['file_directory'];
  $field_info     = field_info_field($field_name);
  $uri_scheme     = $field_info['settings']['uri_scheme'];

  // Create the storage directory if it doesn't exist.
  $storage_directory = $uri_scheme . '://' . $file_directory;
  $directory_exists = file_prepare_directory($storage_directory, FILE_CREATE_DIRECTORY);

  // If the directory exists (or it was successfully created), proceed with
  // downloading the file and attaching it to the field. If not, and it could
  // not be created, a watchdog error must have been logged by Drupal as a PHP
  // notice/warning, so we don't need to do it here again. Instead, we display a
  // generic error message to the user and return.
  if (!$directory_exists) {
    drupal_set_message(
      t('An unexpected error has occurred, please try again. If the error persists, contact the site administrator'),
      'error'
    );
    return;
  }

  // Download and save the file.
  $client = bonsai_get_client();
  $response = $client->get($attachment->url);
  if ($response->http_response_code !== 200) {
    watchdog(
      'bonsai',
      "Unsuccessful response code $response->http_response_code when trying to download a message attachment from $attachment->url",
      array(),
      WATCHDOG_ERROR
    );
    drupal_set_message(
      t('The file could not be retrieved from the email service provider, please try again. If the problem persists, contact the site administrator.'),
      'error'
    );
    return;
  }

  // If the response code is OK, the data should be containing the file. Create
  // a Drupal file object with it.
  $file = file_save_data(
    $response->http_response_body,
    $storage_directory . '/' . $attachment->name,
    FILE_EXISTS_RENAME
  );
  // Since we are assigning automatically fetched messages to the superuser, we
  // should do the same for automatically fetched attachments e.g. not manually
  // uploaded by a user. Both (fetched messages and attachments) should
  // correspond to received messages. Sent messages and attachments are created
  // first as Drupal nodes/files, and then send as emails, so we should never be
  // inside this function when handling sent messages.
  $file->uid = 1;
  // We will always immediately attach the file to a node, so the status should
  // be permanent so it won't be deleted during cron.
  $file->status = 1;

  // Do validation before saving the file, according to settings defined in the
  // field instance.
  $validators = array(
    'file_validate_size'        => array(parse_size($instance_info['settings']['max_filesize'])),
    'file_validate_extensions'  => array($instance_info['settings']['file_extensions']),
    'file_validate_name_length' => array(),
  );
  if ($field_info['type'] === 'image') {
    $validators += array(
      'file_validate_is_image'         => array(),
      'file_validate_image_resolution' => array($instance_info['settings']['max_resolution']),
    );
  }
  $errors = file_validate(
    $file,
    $validators
  );

  // Do not save the file if there are validation errors. Set the error messages
  // to be displayed to the user, and return.
  if ($errors) {
    foreach ($errors as $error) {
      drupal_set_message($error, 'error');
    }
    return;
  }

  // Proceed with saving the file if there are no errors.
  file_save($file);

  // Attach the file to the given node. We need to set the 'display' field
  // property since it is required. If the field settings provide a default, we
  // use that, if not we set it to 1 which is the default in that case.
  if ($field_info['type'] === 'file') {
    if ($field_info['settings']['display_field']) {
      $file->display = $field_info['settings']['display_default'];
    }
    else {
      $file->display = 1;
    }
  }
  $files = $node_wrapper->{$field_name}->value();
  if ($files) {
    $files[] = (array) $file;
  }
  else {
    $files = array((array) $file);
  }
  $node_wrapper->{$field_name}->set($files);

  // Update the file usage table.
  file_usage_add($file, 'file', 'node', $node_wrapper->getIdentifier());

  // Save the node with the updated file field.
  $node_wrapper->save();

  /**
   * @Issue(
   *   "Field caches are not cleared when saving only the individual file field
   *   when adding attachments"
   *   type="improvement"
   *   priority="low"
   *   labels="performance"
   * )
   * // Save only the individual field instead of saving the full node.
   * $fields = array(field_info_field($field_name)['id']);
   * field_sql_storage_field_storage_write('node', $node_wrapper->value(), 'update', $fields);
   *
   * // Clear field cache
   * $nid = $node_wrapper->getIdentifier();
   * cache_clear_all("field:node:$nid", 'cache_field');
   */
}

/**
 * @Issue(
 *   "Move page callbacks into a bonsai.pages.inc file"
 *   type="improvement"
 *   priority="low"
 *   labels="structure"
 * )
 * @Issue(
 *   "Properly handle error cases instead of always returning 404"
 *   type="improvement"
 *   priority="low"
 *   labels="correctedness"
 * )
 */
function _bonsai_attachments_add_page($node) {
  // Attachments are meant to be added via a POST request.
  if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
    drupal_not_found();
    return;
  }

  // Currently only the node type provided by this module is supported.
  if (empty($node) || $node->type !== 'bonsai_message_email') {
    drupal_not_found();
    return;
  }

  $node_wrapper = entity_metadata_wrapper('node', $node);

  /**
   * @Issue(
   *   "Find a way to detect whether an attachment has already been added to the
   *   node"
   *   type="bug"
   *   priority="low"
   *   labels="data"
   * )
   */

  // Make sure that the attachment url is given.
  /**
   * @Issue(
   *   "Support a request to attach all message's attachment to the
   *   corresponding node"
   *   type="improvement"
   *   priority="normal"
   *   labels="ux"
   * )
   */
  if (empty($_POST['url'])) {
    drupal_not_found();
    return;
  }

  $attachment = NULL;

  // Check if the requested attachment url actually belongs to the message
  // corresponding to the node where the attachment will be added.
  $message = json_decode($node_wrapper->bonsai_json->value());
  if (!empty($message->attachments)) {
    // Get all the details of the attachment.
    foreach ($message->attachments as $message_attachment) {
      if ($_POST['url'] === $message_attachment->url) {
        $attachment = $message_attachment;
      }
    }
  }

  // If the attachment was not found, it does not belong to this message.
  if (empty($message->attachments)) {
    drupal_not_found();
    return;
  }

  // All looks good, add the attachment to the node.
  _bonsai_node_add_attachment($attachment, $node_wrapper);

  /**
   * @Issue(
   *   "Allow a redirect url via a query parameter to accommodate adding
   *   attachments from pages other than the node view page"
   *   type="improvement"
   *   priority="low"
   * )
   */

  // Go back to the node page.
  drupal_goto('node/' . $node_wrapper->getIdentifier());
}

function _bonsai_attachments_add_access($node) {
  // We allow users to add attachments if they have the related permission, and
  // they can also update the node.
  /**
   * @Issue(
   *   "Review what is the best permissions choice for allowing fetching message
   *   attachments"
   *   type="task"
   *   priority="low"
   *   labels="investigation"
   * )
   */
  return node_access('update', $node) && user_access('bonsai fetch attachments');
}
