<?php
/**
 * @file
 * Code for the Bonsai feature.
 */

include_once 'bonsai.features.inc';
include_once 'includes/bonsai.theme.inc';
include_once 'includes/bonsai.field_formatter.inc';

// External dependencies.
use Bonsai\Mailgun\Repository;
use Mailgun\Connection\Exceptions\MissingEndpoint;
use Symfony\Component\EventDispatcher\EventDispatcher;

// Internal dependencies.
use Drupal\bonsai\Mailgun\MessageToNodeTransformer;


/**
 * @Issue(
 *   "Define admin page for setting required system variables"
 *   type="improvement"
 *   priority="normal"
 *   labels="administration, configuration"
 * )
 * @Issue(
 *   "Throw exceptions when required configuration variables are not defined"
 *   type="improvement"
 *   priority="normal"
 *   labels="configuration"
 * )
 * @Issue(
 *   "Add a composer.json file for defining composer dependencies"
 *   type="bug"
 *   priority="normal"
 * )
 * @Issue(
 *   "Allow users to change the default authentic/spam field, or flag messages
 *   using the flag module"
 *   type="improvement"
 *   priority="normal"
 * )
 * @Issue(
 *   "Detect when delivery fails and allow sending the email again"
 *   type="bug"
 *   priority="normal"
 * )
 */


/**
 * Hooks.
 */

/**
 * Implements hook_menu().
 */
function bonsai_menu() {
  $items = array();

  // Menu item for image attachment call for message nodes.
  $items['bonsai/messages/%node/attachments/add'] = array(
    'title' => 'Add Attachments',
    'page callback' => '_bonsai_attachments_add_page',
    'page arguments' => array(2),
    'access callback' => '_bonsai_attachments_add_access',
    'access arguments' => array(2),
  );

  // Menu item for sending messages.
  $items['bonsai/messages/%node/send'] = array(
    'title' => 'Send Message',
    'page callback' => '_bonsai_messages_send_page',
    'page arguments' => array(2),
    'access callback' => '_bonsai_messages_send_access',
    'access arguments' => array(2),
    'file' => 'includes/bonsai.pages.inc',
    'file path' => drupal_get_path('module', 'bonsai'),
  );

  // Menu item for cloning messages.
  $items['bonsai/messages/%node/clone'] = array(
    'title' => 'Clone Message',
    'page callback' => '_bonsai_messages_clone_page',
    'page arguments' => array(2),
    'access callback' => '_bonsai_messages_clone_access',
    'access arguments' => array(2),
    'file' => 'includes/bonsai.pages.inc',
    'file path' => drupal_get_path('module', 'bonsai'),
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function bonsai_permission() {
  $permissions = array(
    'bonsai fetch attachments' => array(
      'title' => t('Fetch attachments from the source and add them to messages'),
    ),
    'bonsai send any messages' => array(
      'title' => t('Send any messages'),
    ),
    'bonsai send own messages' => array(
      'title' => t('Send own messages'),
    ),
    'bonsai view any published messages' => array(
      'title' => t('View any published messages'),
    ),
    'bonsai view any unpublished messages' => array(
      'title' => t('View any unpublished messages'),
    ),
    'bonsai view own unpublished messages' => array(
      'title' => t('View own unpublished messages'),
    ),
    'bonsai view messages source' => array(
      'title' => t('View the source of messages'),
    ),
  );

  return $permissions;
}

/**
 * Implements hook_node_access_records().
 *
 * Messages are published when sent, or when they are incoming messages. Newly
 * created messages that are not incoming, are considered as drafts and are not
 * published. By default, all site users (having the view published content
 * permission) would be able to see published messages. We therefore define a
 * realm corresponding to the 'bonsai view any messages' permission so that we
 * can restrict view access to messages.
 *
 * At the same time, we want bonsai users to be able to view unpublished
 * messages. We don't want to use the 'view unpublished content' permission
 * since it could be too generic depending on the application. We therefore use
 * custom 'view own/any unpublished' permissions and corresponding realms to
 * allow bonsai users to view their own unpublished messages.
 *
 * Edit any/own and delete any/own permissions are defined by Drupal core per
 * content type, so we may not need to implement that for now.
 */
function bonsai_node_access_records($node) {
  $grants = array();

  if ($node->type !== 'bonsai_message_email') {
    return array();
  }

  if ($node->status) {
      $grants[] = array(
      'realm' => 'bonsai_view_any_published_messages',
      'gid' => 1,
      'grant_view' => 1,
      'grant_update' => 0,
      'grant_delete' => 0,
      'priority' => 0,
    );
  }
  else {
    $grants[] = array(
      'realm' => 'bonsai_view_any_unpublished_messages',
      'gid' => 1,
      'grant_view' => 1,
      'grant_update' => 0,
      'grant_delete' => 0,
      'priority' => 0,
    );
    $grants[] = array(
      'realm' => 'bonsai_view_own_unpublished_messages',
      'gid' => $node->uid,
      'grant_view' => 1,
      'grant_update' => 0,
      'grant_delete' => 0,
      'priority' => 0,
    );
  }

  return $grants;
}

/**
 * Implements hook_node_grants().
 */
function bonsai_node_grants($account, $op) {
  $grants = array();

  if (user_access('bonsai view any published messages', $account)) {
    $grants['bonsai_view_any_published_messages'][] = array(1);
  }
  if (user_access('bonsai view any unpublished messages', $account)) {
    $grants['bonsai_view_any_unpublished_messages'][] = array(1);
  }
  if (user_access('bonsai view own unpublished messages')) {
    $grants['bonsai_view_own_unpublished_messages'][] = array($account->uid);
  }

  return $grants;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function bonsai_form_bonsai_message_email_node_form_alter(&$form, &$form_state, $form_id) {
  // Improve the 'Add another item' buttons for adding multiple recipients.
  $fields = array(
    'bonsai_emails'  => 'Add recipients',
    'bonsai_emails2' => 'Add CC recipients',
    'bonsai_emails3' => 'Add BCC recipients',
  );

  foreach ($fields as $field_name => $title) {
    $language = $form[$field_name]['#language'];
    $form[$field_name][$language]['add_more']['#value'] = '<span class="fa fa-plus"></span> ' . t($title);
    $form[$field_name][$language]['add_more']['#attributes']['class'][] = 'btn-sm btn-info';
  }

  // We will be populating the user fields in hook_node_presave(), so disallow
  // all users from updating these fields.
  $form['bonsai_user_ref']['#access']   = FALSE;
  $form['bonsai_users_ref']['#access']  = FALSE;
  $form['bonsai_users_ref2']['#access'] = FALSE;
  $form['bonsai_users_ref3']['#access'] = FALSE;

  // Mailgun will be creating a plain text version of the HTML body, so let's
  // only make the HTML field with a text editor available.
  $form['bonsai_text_long']['#access'] = FALSE;

  // The following fields are automatically set, either upon creation or when
  // the email will actually be sent.
  $form['og_bonsai_emails_ref']['#access'] = FALSE;
  $form['bonsai_email_id']['#access']      = FALSE;
  $form['bonsai_timestamp']['#access']     = FALSE;
  $form['bonsai_json']['#access']          = FALSE;

  // The title will be automatically generated from the subject.
  $form['title']['#access'] = FALSE;

  // Additionally, if the node is published, or if it is a draft awaiting
  // delivery, we don't allow updating any fields apart from the metadata
  // fields.
  if ($form['#node']->status || !empty($form['#node']->bonsai_email_id)) {
    $form['bonsai_email']['#access'] = FALSE;
    $form['bonsai_emails']['#access'] = FALSE;
    $form['bonsai_emails2']['#access'] = FALSE;
    $form['bonsai_emails3']['#access'] = FALSE;
    $form['bonsai_email_subject']['#access'] = FALSE;
    $form['bonsai_text_long2']['#access'] = FALSE;
    $form['bonsai_files']['#access'] = FALSE;
    $form['bonsai_images']['#access'] = FALSE;
  }

  // Display an info message showing the email message that the current is a
  // reply to. We are hiding the autocomplet for the In Reply To field via
  // 'entityreference_prepopulate' module.
  $language = $form['bonsai_message_email_ref']['#language'];
  $reply_to_id = $form['bonsai_message_email_ref'][$language][0]['target_id']['#default_value'];
  if ($reply_to_id) {
    // The value in entityreference field is given as 'Title (id)'. We need to
    // extract the id so that can load the node and display its title as a
    // link. We start looking for a parenthesis from the end, just in case the
    // title contains a parenthesis.
    $id_start = strpos($reply_to_id, '(');
    $reply_to_id = substr($reply_to_id, $id_start+1, -1);
    $reply_to_node = node_load($reply_to_id);
    $uri = entity_uri('node', $reply_to_node);
    $uri['options'] += array('attributes' => array('target' => '_blank'));
    $reply_to_link = l($reply_to_node->title, $uri['path'], $uri['options']);
    $form['in_reply_to'] = array(
      '#markup' => '<div class="alert alert-info"><span class="fa fa-info"></span>This message is in reply to: ' .$reply_to_link . '</div>',
      '#weight' => -100,
    );
  }

  // Code for new messages only from here on.
  if ($form['nid']['#value']) {
    return;
  }

  // Code for reply-messages only from here on.
  if (empty($reply_to_node)) {
    return;
  }

  // We only prepopulate information (sender/recipients/body quote) if the
  // 'reply' query parameter is set. If it set to 'all' we will prepopulate as
  // much information as we can. Otherwise, we will prepopulate the Sender and
  // one Recipient, and the body quote.
  $query_parameters = drupal_get_query_parameters();
  if (empty($query_parameters['reply'])) {
    return;
  }

  $reply_to_node_wrapper = entity_metadata_wrapper('node', $reply_to_node);

  // Set the subject e.g. the subject of the message we're replying to with a
  // 'Re: ' prefix.
  /**
   * @Issue(
   *   "Allow language configuration for the reply subject and quote prefixes"
   *   type="improvement"
   *   priority="low"
   *   labels="ux"
   * )
   */
  $language = $form['bonsai_email_subject']['#language'];
  $form['bonsai_email_subject'][$language][0]['value']['#default_value'] = 'Re: ' . check_plain($reply_to_node_wrapper->bonsai_email_subject->value());

  // 'From' and 'Date' information that will be used to create the reply quote
  // prefix.
  $reply_to_from = $reply_to_node_wrapper->bonsai_email->value();
  $reply_to_date = $reply_to_node_wrapper->bonsai_timestamp->value();
  $reply_to_date = gmdate('l, d F Y H:i:s T', $reply_to_date);

  // 'Body' of the message we're replying to that will be added as a quote in
  // the new email. We will prefer to the HTML body, with a fallback to plain
  // text if the HTML body does not exist.
  $reply_to_body = $reply_to_node_wrapper->bonsai_text_long2->value();
  if ($reply_to_body) {
    $reply_to_body = $reply_to_body['value'];
  }
  else {
    $reply_to_body = $reply_to_node_wrapper->bonsai_text_long->value();
  }

  // Create the reply-to quote and insert it into the new message's HTML body.
  $reply_to_body_quote_header = 'On ' . $reply_to_date . ', ' . htmlspecialchars($reply_to_from) . ' wrote:';
  $reply_to_body_quote = "<p></p><p></p><p>$reply_to_body_quote_header</p><blockquote>$reply_to_body</blockquote>";
  $language = $form['bonsai_text_long2']['#language'];
  $form['bonsai_text_long2'][$language][0]['#format'] = 'bonsai_html';
  $form['bonsai_text_long2'][$language][0]['#default_value'] = $reply_to_body_quote;

  // Prepopulate the sender and recipients fields as best we can, based on the
  // sender and the recipients of the message we're replying to.
  /**
   * @Issue(
   *   "Properly prepopulate sender/recipients when replying to an email sent by
   *   the bonsai domain"
   *   type="improvement"
   *   priority="low"
   *   labels="ux"
   * )
   */
  // We'll be using the sender and the recipients of the node we're replying
  // to prepopulate the sender and the recipients of the message we're
  // currently composing.
  $reply_to_recipients    = $reply_to_node_wrapper->bonsai_emails->value();
  $reply_to_cc_recipients = $reply_to_node_wrapper->bonsai_emails2->value();

  // We'll try to guess the mostly likely email that the user will be
  // sending from, as the first recipient email of the node we're replying
  // to that belongs to the bonsai domain.
  // The email could have been sent to many emails of that domain. We'll
  // pick the first one. If there is no domain in the recipients, we'll
  // check the CC recipients as well.
  $domain   = variable_get('bonsai_domain');
  $language = $form['bonsai_email']['#language'];
  $from     = &$form['bonsai_email'][$language][0]['email']['#default_value'];
  foreach ($reply_to_recipients as $index => $recipient) {
    if (_bonsai_email_get_domain($recipient) === $domain) {
      $from = $recipient;
      // We're unsetting the item. Since we're putting it into the 'from'
      // field, we don't want it left in te recipients to reply to as well.
      unset($reply_to_recipients[$index]);
      break;
    }
  }
  if (!$from && $reply_to_cc_recipients) {
    foreach ($reply_to_cc_recipients as $index => $cc_recipient) {
      if (_bonsai_email_get_domain($cc_recipient) === $domain) {
        $from = $cc_recipient;
        // We're unsetting the item if found within the CC recipients, for
        // the same reason we did so in the To recipients.
        unset($reply_to_cc_recipients[$index]);
        break;
      }
    }
  }

  // We set the first recipient, which will always be the the sender of the
  // email we're replying to.
  $form['bonsai_emails'][$language][0]['email']['#default_value'] = $reply_to_from;

  // If the query parameter is set to 'all', we want to reply not only to
  // the sender, but to all To and CC recipients as well.
  /**
   * @Issue(
   *   "The reply-to prepopulated recipients do not appear in the specified
   *   order"
   *   type="bug"
   *   priority="low"
   *   labels="ux"
   * )
   * @Issue(
   *   "Trying to remove a prepopulated recipient results in an error"
   *   type="bug"
   *   priority="low"
   *   labels="ux"
   * )
   * @Issue(
   *   "When creating new items in multi-value email form elements, do we need
   *   to set the value in $form['#node'] as well?"
   *   type="bug"
   *   priority="low"
   *   notes="https://www.drupal.org/node/2017457"
   * )
   */
  if ($query_parameters['reply'] === 'all') {
    // To recipients.
    if ($reply_to_recipients) {
      $language   = $form['bonsai_emails']['#language'];
      $field_item = $form['bonsai_emails'][$language][0];
      foreach ($reply_to_recipients as $index => $recipient) {
        // We're storing items in $index+1 position since the 0 position is
        // already set to the sender of the email we're replying to.
        $form['bonsai_emails'][$language][$index+1] = $field_item;
        $form['bonsai_emails'][$language][$index+1]['email']['#default_value'] = $recipient;
      }
    }

    // CC recipients.
    if ($reply_to_cc_recipients) {
      $language   = $form['bonsai_emails2']['#language'];
      $field_item = $form['bonsai_emails2'][$language][0];
      foreach ($reply_to_cc_recipients as $index => $cc_recipient) {
        if ($index > 0) {
          $form['bonsai_emails2'][$language][$index] = $cc_field_item;
        }
        $form['bonsai_emails2'][$language][$index]['email']['#default_value'] = $cc_recipient;
      }
    }
  }
}

/**
 * Implements hook_node_presave().
 */
function bonsai_node_presave($node) {
  if ($node->type !== 'bonsai_message_email') {
    return;
  }

  // Set the title to be the email's subject (up to 255 characters due to
  // database restriction).
  $node_wrapper = entity_metadata_wrapper('node', $node);
  $subject = $node_wrapper->bonsai_email_subject->value();
  if ($subject) {
    $node_wrapper->title->set(substr($subject, 0, 255));
  }
  else {
    $node_wrapper->title->set('No subject');
  }

  // Update the user reference fields.
  _bonsai_update_message_users($node);
}

/**
 * Implements hook_cron().
 *
 * Defines a cron item for regularly fetching incoming or delivered messages
 * from the email service provider.
 */
function bonsai_cron() {
  _bonsai_cron__bonsai_messages_incoming();
  _bonsai_cron__bonsai_messages_delivered();
}

/**
 * Implements hook_cron_queue_info().
 */
function bonsai_cron_queue_info() {
  $items = array();

  // Queue for processing newly fetched messages.
  $items['bonsai_messages_incoming'] = array(
    'worker callback' => '_bonsai_queue_worker__bonsai_messages_incoming',
  );

  // Queue for processing newly fetched messages.
  $items['bonsai_messages_delivered'] = array(
    'worker callback' => '_bonsai_queue_worker__bonsai_messages_delivered',
  );

  // Queue for detecting the parents of an email. It may also be used to add a
  // message to a new or existing conversation.
  $items['bonsai_conversations'] = array(
    'worker callback' => '_bonsai_queue_worker__bonsai_conversations',
  );

  return $items;
}


/**
 * Hooks - indirect implementations.
 */

/**
 * Implements hook_cron via bonsai_cron().
 */
function _bonsai_cron__bonsai_messages_incoming() {
  // Fetch incoming messages from the email service provider.
  $domain     = variable_get('bonsai_domain');
  $repository = bonsai_get_repository(array('transform_messages' => TRUE));
  $messages   = $repository->getList(
    array(
      'domain' => $domain,
      /**
       * @Issue(
       *   "Define the number of messages to fetch per cron run as a system
       *   variable"
       *   type="improvement"
       *   priority="low"
       *   labels="administration, configuration"
       * )
       */
      'limit'  => variable_get('bonsai_cron_messages_limit', 100),
    )
  );

  if (empty($messages)) {
    return;
  }

  $queue = DrupalQueue::get('bonsai_messages_incoming');

  // Store each message to the queue for separately processing it later.
  foreach ($messages as $message) {
    if (empty($message)) {
      continue;
    }

    // Do not reprocess messages that have already been stored as nodes.
    /**
     * @Issue(
     *   "Use an EventSubscriber for filtering out messages that have already
     *   been processed"
     *   type="improvement"
     *   priority="performance"
     * )
     */
    $node_exists = _bonsai_email_message_exists($message, TRUE);
    if ($node_exists) {
      return;
    }

    $queue->createItem($message);
  }
}

/**
 * Implements hook_cron via bonsai_cron().
 */
function _bonsai_cron__bonsai_messages_delivered() {
  // Fetch delivered messages from the email service provider.
  $domain     = variable_get('bonsai_domain');
  $repository = bonsai_get_repository();
  $messages   = $repository->getList(
    array(
      'domain'     => $domain,
      'event_type' => 'delivered',
      'limit'      => variable_get('bonsai_cron_messages_limit', 100),
    )
  );

  if (empty($messages)) {
    return;
  }

  $queue = DrupalQueue::get('bonsai_messages_delivered');

  // Store each message to the queue for separately processing it later.
  foreach ($messages as $message) {
    if (empty($message)) {
      continue;
    }

    // If the email is tagged as transactional, ignore it.
    /**
     * @Issue(
     *   "Test case where a transactional email has other tags as well"
     *   type="bug"
     *   priority="normal"
     * )
     * @Issue(
     *   "Consider tagging all Bonsai generated email messages and excluding all
     *   other emails"
     *   type="improvement"
     *   priority="normal"
     * )
     * @Issue(
     *   "Allow configuring the exclusion method and corresponding tags via
     *   module configuration"
     *   type="improvement"
     *   priority="normal"
     *   labels="configuration"
     * )
     */
    if (!empty($message->{'X-Mailgun-Tag'}) && $message->{'X-Mailgun-Tag'} === 'transactional') {
      continue;
    }

    // Do not reprocess delivered message nodes that have already been updated.
    /**
     * @Issue(
     *   "Use an EventSubscriber for filtering out delivered messages that have
     *   already been processed"
     *   type="improvement"
     *   priority="performance"
     * )
     */
    $node = _bonsai_message_node_by_email_id($message->{'Message-Id'}, TRUE);
    if (!$node) {
      watchdog(
        'bonsai',
        'No node was found for the delivered message with ID "@message_id".',
        array(
          '@message_id' => _bonsai_email_trim_email_id($message->{'Message-Id'}),
        ),
        WATCHDOG_ERROR
      );
      continue;
    }

    $node_wrapper = entity_metadata_wrapper('node', $node);
    // If the node was found, we check if it has already been published. If it
    // does, it means that the node has already been updated - skip it.
    if ($node_wrapper->status->value()) {
      continue;
    }

    // If the node is unpublished but it has JSON source, there is something
    // wrong. Log an error message and skip.
    if ($node_wrapper->bonsai_json->value()) {
      watchdog(
        'bonsai',
        'Trying to update a node (!node_id) that contains email JSON source with the details of the delivered message with email ID "@message_id".',
        array(
          '!node_id' => $node_wrapper->getIdentifier(),
          '@message_id' => _bonsai_email_trim_email_id($message->{'Message-Id'})
        ),
        WATCHDOG_ERROR
      );
      continue;
    }

    $update_info = array(
      'node_id' => $node_wrapper->getIdentifier(),
      'message' => json_encode($message),
    );

    $queue->createItem($update_info);
  }
}


/**
 * Public API.
 */

/**
 * Get the client for the email service provider.
 *
 * The client is required for creating the repository for the email service
 * provider. It could be created by a Service Container, but Drupal 7 does not
 * have one. It may also be used to make direct requests to the service
 * provider's API.
 *
 * Only Mailgun is supported at the moment, so we create and return the client
 * directly.
 */
function bonsai_get_client() {
  $api_key = variable_get('bonsai_mailgun_api_key');
  return new \Mailgun\Mailgun($api_key);
}

/**
 * Get the repository for the email service provider.
 *
 * The repository is used for fetching or sending email messages.
 *
 * Only Mailgun is supported at the moment, so we create and return the
 * repository directly.
 */
function bonsai_get_repository(array $options = array()) {
  $options = array_merge(
    array(
      'dispatch_events'    => FALSE,
      'transform_messages' => FALSE,
    ),
    $options
  );

  $api_key = variable_get('bonsai_mailgun_api_key');
  $client  = bonsai_get_client();

  // The caller may provide an Event Dispatcher that will be used to dispatch
  // events for modifying Mailgun Events before the Bonsai PHP library fetches
  // the messages corresponding to them.
  $dispatcher = NULL;
  if ($options['dispatch_events']) {
    $dispatcher  = new EventDispatcher();
  }

  // The caller may provide a Message Transformer which will be used by the
  // Bonsai PHP library to transform the Mailgun Messages into a desired format
  // e.g. a Drupal node, before returning them.
  $transformer = NULL;
  if ($options['transform_messages']) {
    $transformer = new MessageToNodeTransformer();
  }

  return new Repository($client, $api_key, $dispatcher, $transformer);
}

function bonsai_can_send_message($node, $account = NULL) {
  // An already published (and therefore sent) message cannot be sent again. The
  // user would have to clone the message, or create a new one, and send that
  // instead.
  /**
   * @Issue(
   *   "Implement re-send functionality as automatically cloning the message and
   *   sending the new one"
   *   type="feature"
   *   priority="low"
   *   lables="ux"
   */
  if ($node->status) {
    return FALSE;
  }

  // We also don't allow sending messages that are already sent but are still
  // awaiting to be delivered, which means they are still in unpublished status.
  // When a message is queued for delivery, the email ID is stored in the node
  // but the node remains unpublished and the JSON source is not available
  // yet. Only checking that the node is unpublished (done above) should be
  // enough though - otherwise there is an error elsewhere in the code.
  $node_wrapper = entity_metadata_wrapper('node', $node);
  if ($node_wrapper->bonsai_email_id->value()) {
    return FALSE;
  }

  // Allow users that can send any message.
  if (user_access('bonsai send any messages', $account)) {
    return TRUE;
  }

  // Allow users that can send their own messages (messages they have created).
  global $user;
  if (!isset($account)) {
    $account = $user;
  }
  if ($node->uid == $account->uid && user_access('bonsai send own messages')) {
    return TRUE;
  }

  return FALSE;
}


/**
 * Callbacks.
 */

/**
 * Implements callback_queue_worker().
 *
 * Given a node entity wrapper that represents a message fetched from the email
 * service provider, it prepares it and stores it as an email message node.
 *
 * @Issue(
 *   "Do the full transformation from message to node during processing queue
 *   items, instead of partly doing so on cron run"
 *   type="improvement"
 *   priority="low"
 * )
 */
function _bonsai_queue_worker__bonsai_messages_incoming($node_wrapper) {
  if (empty($node_wrapper)) {
    return;
  }

  // Make sure that the message does not already exists. This shouldn't happen
  // since we check before creating the queue item as well, but it is good to
  // double check to prevent duplicate messages in the case of a regression bug.
  $node_exists = _bonsai_email_message_exists($node_wrapper, TRUE);
  if ($node_exists) {
    return;
  }

  /**
   * @Issue(
   *   "Detect and store users that correspond to sender and recipients"
   *   type="bug"
   *   priority="normal"
   *   labels="data"
   * )
   */

  // Detect if there is a parent email, and save its id in the appropriate
  // field.
  $parent_email_id = _bonsai_email_email_has_header($node_wrapper->bonsai_json->value(), 'In-Reply-To');

  if ($parent_email_id) {
    $parent_node_id = _bonsai_message_node_id_by_email_id($parent_email_id, TRUE);
    if ($parent_node_id) {
      $node_wrapper->bonsai_message_email_ref = $parent_node_id;
    }
  }

  $node_wrapper->save();

  // If the email has a parent, but a node does not already exist for the
  // parent, we create a queue item for detecting it later. It may be that the
  // parent email is in the queue and the corresponding node has not been
  // created yet.
  if ($parent_email_id && !$parent_node_id) {
    $queue = DrupalQueue::get('bonsai_conversations');
    $queue->createItem($node_wrapper->getIdentifier());
  }
}

/**
 * Implements callback_queue_worker().
 *
 * Given a node ID and the JSON source of a delivered email, update the node
 * with relevant information from the source. The purpose is to update draft
 * email message nodes once they have been delivered and mark them as published.
 */
function _bonsai_queue_worker__bonsai_messages_delivered($update_info) {
  if (empty($update_info)) {
    return;
  }

  // Validate that we have the required data available.
  if (empty($update_info['node_id']) || empty($update_info['message'])) {
    throw new \Exception('Not all required data is available for processing an item of the "bonsai_messages_delivered" queue');
  }


  $messageId    = $update_info['message']->{'Message-Id'};
  $node         = node_load($update_info['node_id']);
  $node_wrapper = entity_metadata_wrapper('node', $node);

  // Check that the node is not already published and that the JSON message is
  // not stored. If one of those conditions is true, there is something wrong
  // and we shouldn't be here.
  /**
   * @Issue(
   *   "Should we be throwing exceptions or only log errors when processing
   *   queue items?"
   *   type="task"
   *   priority="low"
   *   labels="error handling, investigation"
   * )
   */
  if ($node_wrapper->status->value()) {
    watchdog(
      'bonsai',
      'Trying to update an already published node (!node_id) with the details of the delivered message with email ID "@message_id". The full delivered message is: "@message"',
      array(
        '!node_id'    => $node_wrapper->getIdentifier(),
        '@message_id' => $messageId,
        '@message'    => $update_info['message'],
      ),
      WATCHDOG_ERROR
    );
    return;
  }
  if ($node_wrapper->bonsai_json->value()) {
    watchdog(
      'bonsai',
      'Trying to update a node (!node_id) that contains email JSON source with the details of the delivered message with email ID "@message_id".',
      array(
        '!node_id'    => $node_wrapper->getIdentifier(),
        '@message_id' => $messageId,
        '@message'    => $update_info['message'],
      ),
      WATCHDOG_ERROR
    );
    return;
  }

  $message     = json_decode($update_info['message']);
  $transformer = new MessageToNodeTransformer();
  $transformer->transform($message, array('node' => $node_wrapper));

  $node_wrapper->save();
}

/**
 * Implements callback_queue_worker().
 *
 * Given the id of an email message node, it detects if the node's email has a
 * parent email that is stored as a node, and it stores it in the corresponding
 * entity reference field that indicates parent relationship.
 */
function _bonsai_queue_worker__bonsai_conversations($node_id) {
  $node         = node_load($node_id);
  $node_wrapper = entity_metadata_wrapper('node', $node);

  // Check if the node's email has a parent email.
  $parent_email_id = _bonsai_email_email_has_header(
    $node_wrapper->bonsai_json->value(),
    'In-Reply-To'
  );

  // Nothing to do if the email does not have a parent. This shouldn't normally
  // happen because we wouldn't put an email that doesn't have a parent in this
  // queue, but it's good to double check in order to prevent errors in the case
  // of a regression bug.
  if (!$parent_email_id) {
    return;
  }

  // Get the parent node, if it exists.
  $parent_node_id = _bonsai_message_node_id_by_email_id($parent_email_id, TRUE);

  // If the parent node exists, store it as a reference in the appropriate
  // field.
  if ($parent_node_id) {
    $node_wrapper->bonsai_message_email_ref = $parent_node_id;
    $node_wrapper->save();
  }
  // If the email has a parent, but a node does not exist for it yet, we
  // create a queue item for detecting it later. It may be that the
  // parent email is still in the queue and the corresponding node has not
  // been created yet.
  /**
   * @Issue(
   *   "Stop trying to repeatedly detect the parent email after a certain
   *   period of time"
   *   type="bug"
   *   priority="low"
   *   labels="cron, deadlock"
   */
  else {
    $queue = DrupalQueue::get('bonsai_conversations');
    $queue->createItem($node_wrapper->getIdentifier());
  }
}


/**
 * Functions for internal use.
 */

/**
 * @Issue(
 *   "Document functions for internal use"
 *   type="improvement"
 *   priority="low"
 *   labels="documentation"
 * )
 */

function _bonsai_ensure_node_wrapper($node_wrapper) {
  // We will be using the entity wrapper for manipulating fields. If we are
  // given the node id or the node object, wrap it in an entity wrapper.
  if (is_numeric($node_wrapper) && is_int((int) $node_wrapper)) {
    $node_wrapper = node_load($node_wrapper);
  }
  if (is_object($node_wrapper) && get_class($node_wrapper) !== 'EntityDrupalWrapper') {
    $node_wrapper = entity_metadata_wrapper('node', $node_wrapper);
  }

  return $node_wrapper;
}

function _bonsai_email_message_exists($node_wrapper, $access_bypass = FALSE) {
  $email_id = $node_wrapper->bonsai_email_id->value();
  return _bonsai_message_node_id_by_email_id($email_id, $access_bypass);
}

function _bonsai_message_node_id_by_email_id($email_id, $access_bypass = FALSE) {
  $email_id = _bonsai_email_trim_email_id($email_id);

  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'node')
    ->propertyCondition('type', 'bonsai_message_email')
    ->fieldCondition('bonsai_email_id', 'value', $email_id)
    ->range(0, 1)
  ;

  // Queue processing via cron runs as anonymous users. They are therefore
  // always denied access to view messages, published or unpublished. In such
  // cases we want to allow bypassing access control.
  if ($access_bypass) {
    $query->addTag(DANGEROUS_ACCESS_CHECK_OPT_OUT);
  }

  $result = $query->execute();

  if (empty($result['node'])) {
    return FALSE;
  }

  return key($result['node']);
}

function _bonsai_message_node_by_email_id($email_id, $access_bypass = FALSE) {
  $node_id = _bonsai_message_node_id_by_email_id($email_id, $access_bypass);

  if ($node_id) {
    return node_load($node_id);
  }

  return FALSE;
}

function _bonsai_email_trim_email_id($email_id) {
  return trim($email_id, '<>');
}

function _bonsai_email_get_domain($email) {
  $email = _bonsai_full_format_to_email($email);
  $email_parts = explode('@', $email);

  return end($email_parts);
}

function _bonsai_message_add_labels($node_wrapper, $labels) {
  if (!$labels) {
    return;
  }

  $node_wrapper = _bonsai_ensure_node_wrapper($node_wrapper);

  $current_terms = $node_wrapper->bonsai_labels_ref->value();
  if ($current_terms) {
    $current_labels = array();
    foreach ($current_terms as $term) {
      $current_labels[] = $term->name;
    }
    $labels = array_diff($labels, $current_labels);
  }

  if (!$labels) {
    return;
  }

  $new_terms = _bonsai_taxonomy_term_multiple_by_name($labels);
  $new_terms = $current_terms + $new_terms;

  $node_wrapper->bonsai_labels_ref->set($new_terms);
}

function _bonsai_full_format_to_email($email) {
  $email_start = strpos($email, '<');

  if ($email_start === FALSE || substr($email, -1) !== '>') {
    return $email;
  }

  return substr($email, $email_start+1, -1);
}

function _bonsai_uids_by_emails(array $emails) {
  if (empty($emails)) {
    return array();
  }

  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'user')
    ->propertyCondition('mail', $emails, 'IN')
  ;
  $result = $query->execute();

  if (empty($result['user'])) {
    return array();
  }

  return array_keys($result['user']);
}

function _bonsai_email_email_has_header($email_json, $header) {
  // Decode the email json if it is passed as string.
  if (is_string($email_json)) {
    $message = json_decode($email_json);
  }
  else {
    $message = $email_json;
  }

  if (empty($message->{'message-headers'})) {
    return FALSE;
  }

  foreach ($message->{'message-headers'} as $message_header) {
    if ($message_header[0] === $header) {
      return $message_header[1];
    }
  }

  return FALSE;
}

function _bonsai_taxonomy_term_multiple_by_name(array $names, array $options = array()) {
  $options = array_merge(
    array(
      'vocabulary' => 'bonsai_labels',
      'tids_only'  => FALSE,
    ),
    $options
  );

  $conditions = array('name' => array_map('trim', $names));
  if (isset($options['vocabulary'])) {
    $vocabularies = taxonomy_vocabulary_get_names();
    if (isset($vocabularies[$options['vocabulary']])) {
      $conditions['vid'] = $vocabularies[$options['vocabulary']]->vid;
    }
    else {
      // Return an empty array when filtering by a non-existing vocabulary.
      return array();
    }
  }

  $terms = taxonomy_term_load_multiple(array(), $conditions);

  if (!$terms) {
    array();
  }

  if ($options['tids_only']) {
    return array_keys($terms);
  }

  return $terms;
}

function _bonsai_node_add_attachment($attachment, $node_wrapper) {
  // We will be using the entity wrapper for manipulating fields. If we are
  // given the node id or the node object, wrap it in an entity wrapper.
  $node_wrapper = _bonsai_ensure_node_wrapper($node_wrapper);

  // Determine the field where the file will be attached, depending on the
  // attachment's content type.
  $image_content_types = array(
    'image/gif',
    'image/jpeg',
    'image/png',
  );
  if (in_array($attachment->{'content-type'}, $image_content_types)) {
    $field_name = 'bonsai_images';
  }
  else {
    $field_name = 'bonsai_files';
  }

  // Get the field settings for determining the full storage path where the file
  // will be stored.
  $instance_info  = field_info_instance('node', $field_name, $node_wrapper->type->value());
  $file_directory = $instance_info['settings']['file_directory'];
  $field_info     = field_info_field($field_name);
  $uri_scheme     = $field_info['settings']['uri_scheme'];

  // Create the storage directory if it doesn't exist.
  $storage_directory = $uri_scheme . '://' . $file_directory;
  $directory_exists = file_prepare_directory($storage_directory, FILE_CREATE_DIRECTORY);

  // If the directory exists (or it was successfully created), proceed with
  // downloading the file and attaching it to the field. If not, and it could
  // not be created, a watchdog error must have been logged by Drupal as a PHP
  // notice/warning, so we don't need to do it here again. Instead, we display a
  // generic error message to the user and return.
  if (!$directory_exists) {
    drupal_set_message(
      t('An unexpected error has occurred, please try again. If the error persists, contact the site administrator'),
      'error'
    );
    return;
  }

  // Download and save the file.
  $client = bonsai_get_client();
  try {
    $response = $client->get($attachment->url);
  }
  catch (MissingEndpoint $e) {
    drupal_set_message(
      t('The attachment could not be retrieved from the email service provider, most likely because it is not available anymore. Email attachments are available for retrieval for 3 days after the email was sent.'),
      'error'
    );
    return;
  }
  if ($response->http_response_code !== 200) {
    watchdog(
      'bonsai',
      "Unsuccessful response code $response->http_response_code when trying to download a message attachment from $attachment->url",
      array(),
      WATCHDOG_ERROR
    );
    drupal_set_message(
      t('The file could not be retrieved from the email service provider, please try again. If the problem persists, contact the site administrator.'),
      'error'
    );
    return;
  }

  // If the response code is OK, the data should be containing the file. Create
  // a Drupal file object with it.
  $file = file_save_data(
    $response->http_response_body,
    $storage_directory . '/' . $attachment->name,
    FILE_EXISTS_RENAME
  );
  // Since we are assigning automatically fetched messages to the superuser, we
  // should do the same for automatically fetched attachments e.g. not manually
  // uploaded by a user. Both (fetched messages and attachments) should
  // correspond to received messages. Sent messages and attachments are created
  // first as Drupal nodes/files, and then send as emails, so we should never be
  // inside this function when handling sent messages.
  $file->uid = 1;
  // We will always immediately attach the file to a node, so the status should
  // be permanent so it won't be deleted during cron.
  $file->status = 1;

  // Do validation before saving the file, according to settings defined in the
  // field instance.
  $validators = array(
    'file_validate_size'        => array(parse_size($instance_info['settings']['max_filesize'])),
    'file_validate_extensions'  => array($instance_info['settings']['file_extensions']),
    'file_validate_name_length' => array(),
  );
  if ($field_info['type'] === 'image') {
    $validators += array(
      'file_validate_is_image'         => array(),
      'file_validate_image_resolution' => array($instance_info['settings']['max_resolution']),
    );
  }
  $errors = file_validate(
    $file,
    $validators
  );

  // Do not save the file if there are validation errors. Set the error messages
  // to be displayed to the user, and return.
  if ($errors) {
    foreach ($errors as $error) {
      drupal_set_message($error, 'error');
    }
    return;
  }

  // Proceed with saving the file if there are no errors.
  file_save($file);

  // Attach the file to the given node. We need to set the 'display' field
  // property since it is required. If the field settings provide a default, we
  // use that, if not we set it to 1 which is the default in that case.
  if ($field_info['type'] === 'file') {
    if ($field_info['settings']['display_field']) {
      $file->display = $field_info['settings']['display_default'];
    }
    else {
      $file->display = 1;
    }
  }
  $files = $node_wrapper->{$field_name}->value();
  if ($files) {
    $files[] = (array) $file;
  }
  else {
    $files = array((array) $file);
  }
  $node_wrapper->{$field_name}->set($files);

  // Update the file usage table.
  file_usage_add($file, 'file', 'node', $node_wrapper->getIdentifier());

  // Save the node with the updated file field.
  $node_wrapper->save();

  /**
   * @Issue(
   *   "Field caches are not cleared when saving only the individual file field
   *   when adding attachments"
   *   type="improvement"
   *   priority="low"
   *   labels="performance"
   * )
   * // Save only the individual field instead of saving the full node.
   * $fields = array(field_info_field($field_name)['id']);
   * field_sql_storage_field_storage_write('node', $node_wrapper->value(), 'update', $fields);
   *
   * // Clear field cache
   * $nid = $node_wrapper->getIdentifier();
   * cache_clear_all("field:node:$nid", 'cache_field');
   */
}

/**
 * Update the user reference fields for the given node.
 *
 * @Issue(
 *   "Optimise the algorithm for updating the users corresponding to a message's
 *   emails"
 *   type="improvement"
 *   priority="low"
 *   labels="performance"
 * )
 */
function _bonsai_update_message_users($node_wrapper) {
  // We will be using the entity wrapper for manipulating fields. If we are
  // given the node id or the node object, wrap it in an entity wrapper.
  $node_wrapper = _bonsai_ensure_node_wrapper($node_wrapper);

  // The emails in minimal format.
  $sender_email          = _bonsai_full_format_to_email($node_wrapper->bonsai_email->value());
  $recipients_emails     = array_map('_bonsai_full_format_to_email', $node_wrapper->bonsai_emails->value());
  $cc_recipients_emails  = array_map('_bonsai_full_format_to_email', $node_wrapper->bonsai_emails2->value());
  $bcc_recipients_emails = array_map('_bonsai_full_format_to_email', $node_wrapper->bonsai_emails3->value());

  // Get a list of all emails so that we fetch the users only once (instead of
  // fetching the users for sender, recipients, CC recipients and BCC recipients
  // separately). That complicates the algorithm a bit, but it can be a
  // significant performance improvement.
  $emails = array_merge(
    array($sender_email),
    $recipients_emails
  );

  if (!empty($cc_recipients_emails)) {
    $emails = array_merge(
      $emails,
      $cc_recipients_emails
    );
  }

  if (!empty($bcc_recipients_emails)) {
    $emails = array_merge(
      $emails,
      $bcc_recipients_emails
    );
  }

  $uids = _bonsai_uids_by_emails($emails);

  // Nothing to do if there are no matching users.
  if (empty($uids)) {
    return;
  }

  $users = user_load_multiple($uids);

  // We loop over found users and we check on which user reference fields they
  // should be added to.
  $sender_found        = FALSE;
  $recipients_uids     = array();
  $cc_recipients_uids  = array();
  $bcc_recipients_uids = array();

  foreach ($users as $user) {
    // Check the sender. The sender can only ever be one, so we use a variable
    // to track when we have found it so that we don't make unnecessary checks.
    if (!$sender_found && $user->mail === $sender_email) {
      $node_wrapper->bonsai_user_ref->set($user->uid);
      $sender_found = TRUE;
    }

    // Check the recipients.
    foreach ($recipients_emails as $email) {
      if ($user->mail === $email) {
        $recipients_uids[] = $user->uid;
      }
    }

    // Check the CC recipients.
    foreach ($cc_recipients_emails as $email) {
      if ($user->mail === $email) {
        $cc_recipients_uids[] = $user->uid;
      }
    }

    // Check the BCC recipients.
    foreach ($bcc_recipients_emails as $email) {
      if ($user->mail === $email) {
        $bcc_recipients_uids[] = $user->uid;
      }
    }
  }

  // Set the users we've found, apart from the sender we has already been set.
  if (!empty($recipients_uids)) {
    $node_wrapper->bonsai_users_ref->set($recipients_uids);
  }
  if (!empty($cc_recipients_uids)) {
    $node_wrapper->bonsai_users_ref2->set($cc_recipients_uids);
  }
  if (!empty($bcc_recipients_uids)) {
    $node_wrapper->bonsai_users_ref3->set($bcc_recipients_uids);
  }
}

/**
 * @Issue(
 *   "Move page callbacks into a bonsai.pages.inc file"
 *   type="improvement"
 *   priority="low"
 *   labels="structure"
 * )
 * @Issue(
 *   "Properly handle error cases instead of always returning 404"
 *   type="improvement"
 *   priority="low"
 *   labels="correctedness"
 * )
 */
function _bonsai_attachments_add_page($node) {
  // Attachments are meant to be added via a POST request.
  if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
    drupal_not_found();
    return;
  }

  // Currently only the node type provided by this module is supported.
  if (empty($node) || $node->type !== 'bonsai_message_email') {
    drupal_not_found();
    return;
  }

  $node_wrapper = entity_metadata_wrapper('node', $node);

  /**
   * @Issue(
   *   "Find a way to detect whether an attachment has already been added to the
   *   node"
   *   type="bug"
   *   priority="low"
   *   labels="data"
   * )
   */

  // Make sure that the attachment url is given.
  /**
   * @Issue(
   *   "Support a request to attach all message's attachment to the
   *   corresponding node"
   *   type="improvement"
   *   priority="normal"
   *   labels="ux"
   * )
   */
  if (empty($_POST['url'])) {
    drupal_not_found();
    return;
  }

  $attachment = NULL;

  // Check if the requested attachment url actually belongs to the message
  // corresponding to the node where the attachment will be added.
  $message = json_decode($node_wrapper->bonsai_json->value());
  if (!empty($message->attachments)) {
    // Get all the details of the attachment.
    foreach ($message->attachments as $message_attachment) {
      if ($_POST['url'] === $message_attachment->url) {
        $attachment = $message_attachment;
      }
    }
  }

  // If the attachment was not found, it does not belong to this message.
  if (empty($message->attachments)) {
    drupal_not_found();
    return;
  }

  // All looks good, add the attachment to the node.
  _bonsai_node_add_attachment($attachment, $node_wrapper);

  /**
   * @Issue(
   *   "Allow a redirect url via a query parameter to accommodate adding
   *   attachments from pages other than the node view page"
   *   type="improvement"
   *   priority="low"
   * )
   */

  // Go back to the node page.
  drupal_goto('node/' . $node_wrapper->getIdentifier());
}

function _bonsai_attachments_add_access($node) {
  // We allow users to add attachments if they have the related permission, and
  // they can also update the node.
  /**
   * @Issue(
   *   "Review what is the best permissions choice for allowing fetching message
   *   attachments"
   *   type="task"
   *   priority="low"
   *   labels="investigation"
   * )
   */
  return node_access('update', $node) && user_access('bonsai fetch attachments');
}

function _bonsai_messages_send_access($node) {
  // Check if the user has the right permissions to send the message.
  return bonsai_can_send_message($node);
}

function _bonsai_messages_clone_access($node) {
  // Check if the user has the right permissions to clone the message.
  return node_access('view', $node) && user_access('create bonsai_message_email content');
}
